default_platform(:android)

platform :android do
  desc "Build and upload to Play Store Internal Track"
  lane :deploy_internal do
    # 1. Ensure Version Code matches version.properties
    props = load_version_properties(file_path: "version.properties")
    build_number = props['VERSION_CODE']
    
    # 0. Smart Version Bump (check against Play Store)
    # This might update version.properties, so we reload props afterwards
    check_and_bump_version_if_needed(
      package_name: 'ch.heuscher.safe_home_button',
      track: 'internal',
      json_key_data: ENV['SUPPLY_JSON_KEY_DATA']
    )
    
    # Reload properties in case they changed
    props = load_version_properties(file_path: "version.properties")
    build_number = props['VERSION_CODE']

    api_key_gemini = ENV['GOOGLE_API_KEY']
    api_key_github = ENV['GH_MODELS_TOKEN']
    
    # 2. Fetch raw commits
    raw_commits = changelog_from_git_commits(
      commits_count: 15, 
      merge_commit_filtering: "exclude_merges",
      pretty: "- %s" 
    )



    ['en-US', 'de-DE'].each do |locale|
      final_notes = nil

      # 3. Try AI Generation (GitHub Models > Gemini)
      if api_key_github || api_key_gemini
        language = locale == 'de-DE' ? "German" : "English"
        prompt = "Summarize these git commits into a friendly, professional release notes list (bullet points) for a mobile app. " \
                 "Target Audience: Seniors. Language: #{language}. " \
                 "Rules: Exclude technical chores/docs/CI. Focus on user-facing features/fixes. " \
                 "CRITICAL: Output must be under 480 characters. No markdown bolding, just plain text bullets."
        
        if api_key_github
          puts "ü§ñ Generating #{language} changelog using GitHub Models (GPT-4o)..."
          final_notes = ask_github_models(api_key_github, prompt, raw_commits)
        elsif api_key_gemini
          puts "‚ú® Generating #{language} changelog using Google Gemini..."
          final_notes = ask_gemini(api_key_gemini, prompt, raw_commits)
        end
      end

      # 4. Fallback: Smart Filter (Rubylogic)
      unless final_notes && !final_notes.empty?
        header = locale == 'de-DE' ? "Neuigkeiten:" : "What's New:"
        filtered = raw_commits.split("\n").select do |line|
           !line.match?(/^(- (chore|docs|test|refactor|style|ci)(\(.*\))?:)/i)
        end.take(10).join("\n")
        final_notes = "#{header}\n#{filtered}"
        
        # Strict Truncation
        final_notes = final_notes[0..485] + "..." if final_notes.length > 490
      end
      
      # Use absolute path to ensure CI runner finds it
      fastfile_dir = File.dirname(__FILE__)
      new_changelog_path = File.expand_path("metadata/android/#{locale}/changelogs/#{build_number}.txt", fastfile_dir)
      
      FileUtils.mkdir_p(File.dirname(new_changelog_path))
      File.write(new_changelog_path, final_notes)
      
      puts "--- Generated Release Notes for #{locale} (Version #{build_number}) ---"
      puts final_notes
      puts "-----------------------------------------------------------------------"
    end

    # Use direct shell command to avoid Fastlane gradle action crash with JVM provisioning output
    root_dir = File.expand_path("..", File.dirname(__FILE__))
    gradlew_path = File.join(root_dir, "gradlew")
    sh "chmod +x #{gradlew_path}" # Ensure executable just in case
    # Execute from project root to ensure settings.gradle.kts is found
    Dir.chdir(root_dir) do
      cmd = "./gradlew bundleRelease --stacktrace --no-configuration-cache"
      puts "Executing raw command: #{cmd}"
      unless system(cmd)
        raise "Gradle build failed! Exit status: #{$?.exitstatus}"
      end
    end
    upload_to_play_store(
      track: 'internal',
      package_name: 'ch.heuscher.safe_home_button',
      aab: File.join(root_dir, "app/build/outputs/bundle/release/app-release.aab")
      # json_key_data is picked up from SUPPLY_JSON_KEY_DATA environment variable
    )

    # 5. Auto-Increment Version (Properties File)
    new_version_name = increment_version_properties(
      file_path: "version.properties"
    )
    
    # 6. Commit the Version Bump
    # Configure Git for CI (Avoid 'Author identity unknown' error)
    # Configure Git for CI (Avoid 'Author identity unknown' error)
    # We set environment variables which git respects globally for this process
    ENV['GIT_AUTHOR_NAME'] = 'Fastlane Deploy'
    ENV['GIT_AUTHOR_EMAIL'] = 'deploy@fastlane.tools'
    ENV['GIT_COMMITTER_NAME'] = 'Fastlane Deploy'
    ENV['GIT_COMMITTER_EMAIL'] = 'deploy@fastlane.tools'

    git_commit(
      path: ["version.properties"],
      message: "chore: bump version to #{new_version_name}"
    )
    push_to_git_remote
  end

  desc "Smart Deploy: Try Production, fallback to Internal if review pending"
  lane :deploy_smart do
    # 1. Ensure Version Code matches version.properties
    props = load_version_properties(file_path: "version.properties")
    build_number = props['VERSION_CODE']
    
    # 0. Smart Version Bump (check against Play Store)
    check_and_bump_version_if_needed(
      package_name: 'ch.heuscher.safe_home_button',
      track: 'internal', # Always check against internal first as it's the gateway
      json_key_data: ENV['SUPPLY_JSON_KEY_DATA']
    )
    # Reload properties
    props = load_version_properties(file_path: "version.properties")
    build_number = props['VERSION_CODE']

    api_key_gemini = ENV['GOOGLE_API_KEY']
    api_key_github = ENV['GH_MODELS_TOKEN']
    
    # 2. Fetch raw commits
    raw_commits = changelog_from_git_commits(
      commits_count: 15, 
      merge_commit_filtering: "exclude_merges",
      pretty: "- %s" 
    )

    # Generate changelogs for both locales
    ['en-US', 'de-DE'].each do |locale|
      final_notes = nil

      if api_key_github || api_key_gemini
        language = locale == 'de-DE' ? "German" : "English"
        prompt = "Summarize these git commits into a friendly, professional release notes list (bullet points) for a mobile app. " \
                 "Target Audience: Seniors. Language: #{language}. " \
                 "Rules: Exclude technical chores/docs/CI. Focus on user-facing features/fixes. " \
                 "CRITICAL: Output must be under 480 characters. No markdown bolding, just plain text bullets."
        
        if api_key_github
          puts "ü§ñ Generating #{language} changelog using GitHub Models (GPT-4o)..."
          final_notes = ask_github_models(api_key_github, prompt, raw_commits)
        elsif api_key_gemini
          puts "‚ú® Generating #{language} changelog using Google Gemini..."
          final_notes = ask_gemini(api_key_gemini, prompt, raw_commits)
        end
      end

      unless final_notes && !final_notes.empty?
        header = locale == 'de-DE' ? "Neuigkeiten:" : "What's New:"
        filtered = raw_commits.split("\n").select do |line|
           !line.match?(/^(- (chore|docs|test|refactor|style|ci)(\(.*\))?:)/i)
        end.take(10).join("\n")
        final_notes = "#{header}\n#{filtered}"
        final_notes = final_notes[0..485] + "..." if final_notes.length > 490
      end
      
      fastfile_dir = File.dirname(__FILE__)
      new_changelog_path = File.expand_path("metadata/android/#{locale}/changelogs/#{build_number}.txt", fastfile_dir)
      
      FileUtils.mkdir_p(File.dirname(new_changelog_path))
      File.write(new_changelog_path, final_notes)
      
      puts "--- Generated Release Notes for #{locale} (Version #{build_number}) ---"
      puts final_notes
      puts "-----------------------------------------------------------------------"
    end

    # Build the AAB
    root_dir = File.expand_path("..", File.dirname(__FILE__))
    gradlew_path = File.join(root_dir, "gradlew")
    sh "chmod +x #{gradlew_path}"
    Dir.chdir(root_dir) do
      cmd = "./gradlew bundleRelease --stacktrace --no-configuration-cache"
      puts "Executing raw command: #{cmd}"
      unless system(cmd)
        raise "Gradle build failed! Exit status: #{$?.exitstatus}"
      end
    end

    aab_path = File.join(root_dir, "app/build/outputs/bundle/release/app-release.aab")
    # 3. Always Deploy to INTERNAL first (Safe, doesn't reset Prod reviews)
    puts "üöÄ Deploying to INTERNAL track..."
    upload_to_play_store(
      track: 'internal',
      package_name: 'ch.heuscher.safe_home_button',
      aab: aab_path
    )
    deployed_track = 'internal'
    puts "‚úÖ Successfully deployed to INTERNAL!"

    # 4. Optional: Upgrade to PRODUCTION
    # Note: We can't 100% reliably check "Pending Review" status via API.
    # To be safe, we only proceed if the user wants this automation.
    # For now, we try to deploy to production. If it fails (some reviews block edits), we just catch it.
    begin
      puts "üöÄ Attempting promotion to PRODUCTION track..."
      # We use the same AAB
      upload_to_play_store(
        track: 'production',
        package_name: 'ch.heuscher.safe_home_button',
        aab: aab_path
      )
      deployed_track = 'production'
      puts "‚úÖ Successfully promoted to PRODUCTION!"
    rescue => e
      puts "‚ö†Ô∏è  Production deployment skipped/failed: #{e.message}"
      puts "‚ÑπÔ∏è  The INTERNAL release (v#{build_number}) is still available and valid."
      puts "    If a review was pending, we successfully avoided breaking the Internal build,"
      puts "    but the attempt to write to Production might have been rejected by API."
    end

    # 4. Auto-Increment Version
    new_version_name = increment_version_properties(
      file_path: "version.properties"
    )
    
    # 5. Commit the Version Bump
    ENV['GIT_AUTHOR_NAME'] = 'Fastlane Deploy'
    ENV['GIT_AUTHOR_EMAIL'] = 'deploy@fastlane.tools'
    ENV['GIT_COMMITTER_NAME'] = 'Fastlane Deploy'
    ENV['GIT_COMMITTER_EMAIL'] = 'deploy@fastlane.tools'

    git_commit(
      path: ["version.properties"],
      message: "chore: bump version to #{new_version_name} [deployed to #{deployed_track}]"
    )
    push_to_git_remote
    
    puts "üéâ Deployment complete! Track: #{deployed_track.upcase}, Version: #{new_version_name}"
  end

  desc "Sync Metadata Only (Repo -> Play Store)"
  lane :sync_metadata do
    upload_to_play_store(
      package_name: 'ch.heuscher.safe_home_button',
      skip_upload_apk: true,
      skip_upload_aab: true,
      skip_upload_images: false,
      skip_upload_screenshots: false
    )
  end

  # Helper to ask GitHub Models (GPT-4o)
  def ask_github_models(api_key, system_prompt, user_text)
    require 'net/http'
    require 'json'
    require 'uri'

    # Endpoint for GitHub Models (Azure AI inference)
    uri = URI("https://models.inference.ai.azure.com/chat/completions")
    request = Net::HTTP::Post.new(uri, 'Content-Type' => 'application/json', 'Authorization' => "Bearer #{api_key}")
    
    request.body = {
      model: "gpt-4o", # Using GPT-4o as requested
      messages: [
        { role: "system", content: system_prompt },
        { role: "user", content: "Commits to process:\n#{user_text}" }
      ],
      temperature: 0.7,
      max_tokens: 500
    }.to_json

    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }
    
    if response.code.to_i >= 200 && response.code.to_i < 300
      json = JSON.parse(response.body)
      return json.dig('choices', 0, 'message', 'content')&.strip
    else
      puts "‚ö†Ô∏è GitHub Models API failed: #{response.code} - #{response.body}"
      return nil
    end
  rescue => e
    puts "‚ö†Ô∏è GitHub Models API Logic Error: #{e.message}"
    return nil
  end

  # Helper to ask Gemini
  def ask_gemini(api_key, system_prompt, user_text)
    require 'net/http'
    require 'json'
    require 'uri'

    uri = URI("https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=#{api_key}")
    request = Net::HTTP::Post.new(uri, 'Content-Type' => 'application/json')
    
    request.body = {
      contents: [{
        parts: [{ text: "#{system_prompt}\n\nCommits to process:\n#{user_text}" }]
      }]
    }.to_json

    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }
    json = JSON.parse(response.body)
    return json.dig('candidates', 0, 'content', 'parts', 0, 'text')&.strip
  rescue => e
    puts "Gemini API failed: #{e.message}"
    return nil
  end

  # Helper to check and bump version if remote is ahead
  def check_and_bump_version_if_needed(package_name:, track:, json_key_data:)
    return unless json_key_data && !json_key_data.empty? # Skip if no key (e.g. local test)

    puts "üîé Checking against Play Store version (Track: #{track})..."
    
    # Fetch track info
    # supply is part of Fastlane
    tracks = google_play_track_version_codes(
      package_name: package_name,
      track: track,
      json_key_data: json_key_data
    )
    
    remote_version_code = tracks.max || 0
    puts "   Remote Version Code: #{remote_version_code}"
    
    # Load local
    fastfile_dir = File.dirname(__FILE__)
    robust_path = File.expand_path("../version.properties", fastfile_dir)
    props = load_version_properties(file_path: robust_path)
    local_version_code = props['VERSION_CODE'].to_i
    
    if remote_version_code >= local_version_code
      new_code = remote_version_code + 1
      puts "‚ö†Ô∏è  Remote version (#{remote_version_code}) is >= Local version (#{local_version_code})."
      puts "üîÑ  Automatically bumping local version to #{new_code} to avoid conflict..."
      
      # Update properties hash
      props['VERSION_CODE'] = new_code.to_s
      # Optional: bump patch version too if we are forced to bump code
      # Or just keep name same but different code. Let's bump patch to be safe/consistent.
      props['VERSION_PATCH'] = (props['VERSION_PATCH'].to_i + 1).to_s
      
      new_version_name = "#{props['VERSION_MAJOR']}.#{props['VERSION_MINOR']}.#{props['VERSION_PATCH']}"
      props['VERSION_NAME'] = new_version_name
      
      # Write back
      File.open(robust_path, 'w') do |file|
        props.each do |k, v|
          file.write("#{k}=#{v}\n")
        end
      end
      puts "‚úÖ  Bumped version to #{new_version_name} (Code: #{new_code})"
    else
      puts "‚úÖ  Local version (#{local_version_code}) is ahead of Remote (#{remote_version_code}). No bump needed."
    end
  rescue => e
    puts "‚ö†Ô∏è  Failed to check/bump version: #{e.message}"
    puts "    Continuing with local version..."
  end

  # Helper to load properties
  def load_version_properties(file_path:)
    # Resolve absolute path relative to this Fastfile to avoid CWD ambiguity
    # Fastfile is in fastlane/, so we go up one level to root
    # version.properties is in root for Save-Home-Button
    
    fastfile_dir = File.dirname(__FILE__)
    robust_path = File.expand_path("../version.properties", fastfile_dir)
    
    UI.message("Loading version properties from: #{robust_path}")
    
    if !File.exist?(robust_path)
      UI.user_error!("Could not find version.properties at #{robust_path}")
    end

    props = {}
    File.foreach(robust_path) do |line|
      next if line.strip.empty? || line.strip.start_with?('#')
      key, value = line.strip.split('=', 2)
      props[key] = value
    end
    props
  end

  # Helper to increment properties file
  def increment_version_properties(file_path:)
    # Robust path resolution
    fastfile_dir = File.dirname(__FILE__)
    robust_path = File.expand_path("../version.properties", fastfile_dir)
    
    props = load_version_properties(file_path: robust_path)

    # Increment
    props['VERSION_CODE'] = (props['VERSION_CODE'].to_i + 1).to_s
    props['VERSION_PATCH'] = (props['VERSION_PATCH'].to_i + 1).to_s
    # Reconstruct Version Name for context
    new_version_name = "#{props['VERSION_MAJOR']}.#{props['VERSION_MINOR']}.#{props['VERSION_PATCH']}"
    # Update hash so it's written back to file
    props['VERSION_NAME'] = new_version_name
    
    # Write back
    File.open(robust_path, 'w') do |file|
      props.each do |k, v|
        file.write("#{k}=#{v}\n")
      end
    end
    
    puts "Bumping version to #{new_version_name} (Code: #{props['VERSION_CODE']})"
    
    return new_version_name
  end
end
